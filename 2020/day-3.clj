(require '[clojure.string :as str])

(loop [trees (map (fn [input] (loop [x (str/split input #"") y '() index (count x)] (if (empty? x) y (recur (butlast x) (if (= (last x) "#") (conj y (if (= index 31) 0 index)) y) (- index 1))))) (str/split-lines (slurp "day-3.txt"))) walk 1 bumps 0] (if (empty? trees) bumps (if (empty? (filter #(= % (mod walk 31)) (first trees))) (recur (rest trees) (+ 3 walk) bumps) (recur (rest trees) (+ 3 walk) (+ 1 bumps)))))

(* (reduce * (map (fn [steps] (loop [trees (map (fn [input] (loop [x (str/split input #"") y '() index (count x)] (if (empty? x) y (recur (butlast x) (if (= (last x) "#") (conj y (if (= index 31) 0 index)) y) (- index 1))))) (str/split-lines (slurp "day-3.txt"))) walk 1 bumps 0] (if (empty? trees) bumps (if (empty? (filter #(= % (mod walk 31)) (first trees))) (recur (rest trees) (+ steps walk) bumps) (recur (rest trees) (+ steps walk) (+ 1 bumps)))))) '(1 3 5 7))) (loop [trees (map (fn [input] (loop [x (str/split input #"") y '() index (count x)] (if (empty? x) y (recur (butlast x) (if (= (last x) "#") (conj y (if (= index 31) 0 index)) y) (- index 1))))) (str/split-lines (slurp "day-3.txt"))) walk 1 bumps 0] (if (empty? trees) bumps (if (empty? (filter #(= % (mod walk 31)) (first trees))) (recur (rest (rest trees)) (+ 1 walk) bumps) (recur (rest (rest trees)) (+ 1 walk) (+ 1 bumps))))))